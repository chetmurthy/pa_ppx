

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Tutorial &mdash; Pa_ppx  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'./',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Built-in PPX Rewriters" href="builtins.html" />
    <link rel="prev" title="Installation" href="installation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Pa_ppx
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#organization-of-findlib-packages">Organization of Findlib Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-pa-ppx-ppx-rewriters">Using <code class="docutils literal"><span class="pre">pa_ppx</span></code> PPX Rewriters</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#batch-compilation-with-make">Batch compilation with Make</a></li>
<li class="toctree-l3"><a class="reference internal" href="#batch-compilation-with-dune">Batch compilation with Dune</a></li>
<li class="toctree-l3"><a class="reference internal" href="#in-the-toplevel">In the toplevel</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#writing-new-ppx-rewriters-upon-pa-ppx">Writing new PPX Rewriters upon Pa_ppx</a></li>
<li class="toctree-l2"><a class="reference internal" href="#an-example-ppx-rewriter-based-on-pa-ppx">An Example PPX Rewriter based on Pa_ppx</a></li>
<li class="toctree-l2"><a class="reference internal" href="#troubleshooting-ppx-rewriter-invocations">Troubleshooting PPX Rewriter Invocations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#debugging-using-not-ocamlfind-preprocess">Debugging using <code class="docutils literal"><span class="pre">not-ocamlfind</span> <span class="pre">preprocess</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#debugging-using-the-ocaml-toplevel">Debugging using the ocaml toplevel</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="builtins.html">Built-in PPX Rewriters</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Pa_ppx</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Tutorial</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/camlp5/camlp5/blob/master/doctutorial.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="tutorial">
<h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<div class="section" id="organization-of-findlib-packages">
<h2>Organization of Findlib Packages<a class="headerlink" href="#organization-of-findlib-packages" title="Permalink to this headline">¶</a></h2>
<p>There are a bunch of findlib packages.  Maybe too many and too
confusing, I can’t tell.  But the general idea is that for each
rewriter or group of rewriters, there are two packages:</p>
<ol class="arabic simple">
<li>the package for linking into a program, viz. <code class="docutils literal"><span class="pre">pa_ppx.deriving_plugins.show.link</span></code></li>
</ol>
<p>2. the package for loading into the toplevel or adding to camlp5 during preprocessing,
viz. <code class="docutils literal"><span class="pre">pa_ppx.deriving_plugins.show</span></code></p>
<p>Note the <code class="docutils literal"><span class="pre">.link</span></code> at the end there.  These are separated like this so
we can specify “preprocess with the show plugin, but don’t link it
into the program” and separately “link the show plugin into the
program, but don’t preprocess with it”.</p>
<p>[I thought of having a “virtual package” that just required the both,
but it turns out that findlib doesn’t support that (and I can see the
reasoning there – it could be a source of hard-to-understand bugs).</p>
</div>
<div class="section" id="using-pa-ppx-ppx-rewriters">
<h2>Using <code class="docutils literal"><span class="pre">pa_ppx</span></code> PPX Rewriters<a class="headerlink" href="#using-pa-ppx-ppx-rewriters" title="Permalink to this headline">¶</a></h2>
<div class="section" id="batch-compilation-with-make">
<h3>Batch compilation with Make<a class="headerlink" href="#batch-compilation-with-make" title="Permalink to this headline">¶</a></h3>
<p>To use <code class="docutils literal"><span class="pre">pa_ppx</span></code> PPX rewriters, let’s start with a really simple file
that works with the standard PPX rewriters (simple_show.ml):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">a1</span> <span class="o">=</span> <span class="nb">int</span> <span class="o">*</span> <span class="nb">int</span> <span class="p">[</span><span class="o">@</span><span class="nd">@deriving</span> <span class="n">show</span><span class="p">]</span>
<span class="n">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">print_string</span> <span class="p">([</span><span class="o">%</span><span class="n">show</span><span class="p">:</span> <span class="n">a1</span><span class="p">]</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
</pre></div>
</div>
<p>and we compile it thus:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ocamlfind</span> <span class="n">ocamlc</span> <span class="o">-</span><span class="n">package</span> <span class="n">ppx_deriving</span><span class="o">.</span><span class="n">show</span> <span class="n">simple_show</span><span class="o">.</span><span class="n">ml</span>  <span class="o">-</span><span class="n">o</span> <span class="n">simple_show</span><span class="o">.</span><span class="n">byte</span>
</pre></div>
</div>
<p>Running it yields:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ ./simple_show.byte
(5, 6)
</pre></div>
</div>
<p>To compile with <code class="docutils literal"><span class="pre">pa_ppx</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ocamlfind</span> <span class="n">ocamlc</span> <span class="o">-</span><span class="n">package</span> <span class="n">pa_ppx</span><span class="o">.</span><span class="n">deriving_plugins</span><span class="o">.</span><span class="n">show</span> <span class="o">-</span><span class="n">syntax</span> <span class="n">camlp5o</span> <span class="n">simple_show</span><span class="o">.</span><span class="n">ml</span> <span class="o">-</span><span class="n">linkpkg</span>  <span class="o">-</span><span class="n">o</span> <span class="n">simple_show</span><span class="o">.</span><span class="n">byte</span>
</pre></div>
</div>
<p>with identical output:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ ./simple_show.byte
(5, 6)
</pre></div>
</div>
<p>There’s really only two important differences:</p>
<ol class="arabic simple">
<li>need to specify the syntax (<code class="docutils literal"><span class="pre">-syntax</span> <span class="pre">camlp5o</span></code>)</li>
<li>instead of <code class="docutils literal"><span class="pre">ppx_deriving.show</span></code> specify <code class="docutils literal"><span class="pre">pa_ppx.deriving_plugins.show</span></code></li>
</ol>
<p>The other linking flags, I just haven’t figured out precisely how to get rid of.</p>
<p>Sometimes more packages must be specified (e.g. for <code class="docutils literal"><span class="pre">expect_test</span></code>
and <code class="docutils literal"><span class="pre">inline_test</span></code>) because <code class="docutils literal"><span class="pre">dune</span></code> is adding those
under-the-covers, and these instructions are all Makefile-friendly.</p>
</div>
<div class="section" id="batch-compilation-with-dune">
<h3>Batch compilation with Dune<a class="headerlink" href="#batch-compilation-with-dune" title="Permalink to this headline">¶</a></h3>
<p>Dune requires that we provide a command that will preprocess, but not
compile.  Since this is cumbersome to do with ocamlfind, <cite>pa_ppx</cite>
builds a number of such preprocessors (basically, one for each
subdirectory, and one that includes them all) and installs them as
part of the package.  In the case of <code class="docutils literal"><span class="pre">simple_show.ml</span></code>, we want the
deriving plugins, which can be invoked thus:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ocamlfind</span> <span class="n">pa_ppx</span><span class="o">/</span><span class="n">camlp5o</span><span class="o">.</span><span class="n">pa_ppx_deriving_plugins</span>  <span class="o">./</span><span class="n">simple_show</span><span class="o">.</span><span class="n">ml</span>
</pre></div>
</div>
<p>[BTW, this command was built using <code class="docutils literal"><span class="pre">mkcamlp5</span></code>, and you can see the
build command in the <code class="docutils literal"><span class="pre">pa_ppx/pa_deriving.plugins</span></code> Makefile.]</p>
<p>With this command, we can modify a dune file pretty easily.  Here’s the modification for
<a class="reference external" href="https://github.com/XVilka/yara-ocaml">Yara</a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">@@</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span> <span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">13</span> <span class="o">@@</span>
  <span class="p">(</span><span class="n">name</span> <span class="n">yara</span><span class="p">)</span>
  <span class="p">(</span><span class="n">public_name</span> <span class="n">yara</span><span class="p">)</span>
  <span class="p">(</span><span class="n">wrapped</span> <span class="n">false</span><span class="p">)</span>
<span class="o">-</span> <span class="p">(</span><span class="n">preprocess</span>
<span class="o">-</span>  <span class="p">(</span><span class="n">pps</span> <span class="n">ppx_deriving</span><span class="o">.</span><span class="n">std</span><span class="p">))</span>
<span class="o">+</span>
<span class="o">+</span><span class="p">;;</span> <span class="p">(</span><span class="n">preprocess</span>
<span class="o">+</span><span class="p">;;</span>  <span class="p">(</span><span class="n">pps</span> <span class="n">ppx_deriving</span><span class="o">.</span><span class="n">std</span><span class="p">))</span>
<span class="o">+</span>
<span class="o">+</span> <span class="p">(</span><span class="n">preprocess</span> <span class="p">(</span><span class="n">action</span>
<span class="o">+</span>      <span class="p">(</span><span class="n">run</span> <span class="n">ocamlfind</span> <span class="n">pa_ppx</span><span class="o">/</span><span class="n">camlp5o</span><span class="o">.</span><span class="n">pa_ppx_deriving_plugins</span> <span class="o">%</span><span class="p">{</span><span class="nb">input</span><span class="o">-</span><span class="n">file</span><span class="p">})</span>
<span class="o">+</span>    <span class="p">))</span>
<span class="o">+</span>
</pre></div>
</div>
<p>and here’s a dunefile that will compile <code class="docutils literal"><span class="pre">test_deriving_show.ml</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">env</span>
  <span class="p">(</span><span class="n">dev</span>
    <span class="p">(</span><span class="n">flags</span> <span class="p">(:</span><span class="n">standard</span> <span class="o">-</span><span class="n">w</span> <span class="o">-</span><span class="mi">27</span> <span class="o">-</span><span class="n">w</span> <span class="o">-</span><span class="mi">32</span><span class="p">))))</span>

<span class="p">(</span><span class="n">executable</span>
 <span class="p">(</span><span class="n">name</span> <span class="n">simple_show</span><span class="p">)</span>
 <span class="p">(</span><span class="n">libraries</span> <span class="n">fmt</span> <span class="n">pa_ppx</span><span class="o">.</span><span class="n">runtime</span> <span class="n">ppx_deriving</span><span class="o">.</span><span class="n">runtime</span><span class="p">)</span>
 <span class="p">(</span><span class="n">preprocess</span> <span class="p">(</span><span class="n">action</span>
      <span class="p">(</span><span class="n">run</span> <span class="n">ocamlfind</span> <span class="n">pa_ppx</span><span class="o">/</span><span class="n">camlp5o</span><span class="o">.</span><span class="n">pa_ppx_deriving_plugins</span> <span class="o">%</span><span class="p">{</span><span class="nb">input</span><span class="o">-</span><span class="n">file</span><span class="p">})</span>
      <span class="p">)))</span>
</pre></div>
</div>
<p>[The warnings must be silenced b/c the test itself elicits warnings,
and I didn’t want to modify it.  OTOH, I didn’t silence all warnings
b/c if there are warnings produced by the generated code, I’d like to
know about them.]</p>
</div>
<div class="section" id="in-the-toplevel">
<h3>In the toplevel<a class="headerlink" href="#in-the-toplevel" title="Permalink to this headline">¶</a></h3>
<p>It’s also straightforward to use <code class="docutils literal"><span class="pre">pa_ppx</span></code> PPX rewriters in the toplevel:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>        <span class="n">OCaml</span> <span class="n">version</span> <span class="mf">4.10</span><span class="o">.</span><span class="mi">0</span>
<span class="c1">#use &quot;topfind.camlp5&quot;;;</span>
<span class="o">-</span> <span class="p">:</span> <span class="n">unit</span> <span class="o">=</span> <span class="p">()</span>
<span class="c1"># #camlp5o ;;</span>
     <span class="n">Camlp5</span> <span class="n">parsing</span> <span class="n">version</span> <span class="mf">8.00</span><span class="o">-</span><span class="n">alpha01</span>
<span class="c1"># #require &quot;pa_ppx.deriving_plugins.show&quot;;;</span>

<span class="c1"># type a1 = int * int [@@deriving show] ;;</span>
<span class="nb">type</span> <span class="n">a1</span> <span class="o">=</span> <span class="nb">int</span> <span class="o">*</span> <span class="nb">int</span>
<span class="n">val</span> <span class="n">pp_a1</span> <span class="p">:</span> <span class="n">a1</span> <span class="n">Fmt</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">fun</span><span class="o">&gt;</span>
<span class="n">val</span> <span class="n">show_a1</span> <span class="p">:</span> <span class="n">a1</span> <span class="o">-&gt;</span> <span class="n">String</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">fun</span><span class="o">&gt;</span>
<span class="c1"># let _ =</span>
  <span class="n">print_string</span> <span class="p">([</span><span class="o">%</span><span class="n">show</span><span class="p">:</span> <span class="n">a1</span><span class="p">]</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span> <span class="p">;;</span>
<span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="o">-</span> <span class="p">:</span> <span class="n">unit</span> <span class="o">=</span> <span class="p">()</span>
<span class="c1">#</span>
</pre></div>
</div>
<p>And again, just the ocaml toplevel phrases:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#use &quot;topfind.camlp5&quot;;;</span>
<span class="c1">#camlp5o ;;</span>
<span class="n">require</span> <span class="s2">&quot;pa_ppx.deriving_plugins.show&quot;</span><span class="p">;;</span>
 <span class="nb">type</span> <span class="n">a1</span> <span class="o">=</span> <span class="nb">int</span> <span class="o">*</span> <span class="nb">int</span> <span class="p">[</span><span class="o">@</span><span class="nd">@deriving</span> <span class="n">show</span><span class="p">]</span> <span class="p">;;</span>
<span class="n">let</span> <span class="n">_</span> <span class="o">=</span>
  <span class="n">print_string</span> <span class="p">([</span><span class="o">%</span><span class="n">show</span><span class="p">:</span> <span class="n">a1</span><span class="p">]</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span> <span class="p">;;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="writing-new-ppx-rewriters-upon-pa-ppx">
<h2>Writing new PPX Rewriters upon Pa_ppx<a class="headerlink" href="#writing-new-ppx-rewriters-upon-pa-ppx" title="Permalink to this headline">¶</a></h2>
<p>In this section, we’ll describe at a high level the process of PPX
rewriter execution in <code class="docutils literal"><span class="pre">Pa_ppx</span></code>, and how that results in the process
for writing new ones.</p>
<p>In <code class="docutils literal"><span class="pre">Pa_ppx</span></code> rewriters are “installed” into the <code class="docutils literal"><span class="pre">camlp5</span></code>
preprocessor (which loads them all, unlike with standard PPX
rewriters, which are sometimes run in separate processes).  The
<code class="docutils literal"><span class="pre">Pa_ppx_base</span></code> module accumulates the list of all loaded rewriters,
and just before applying them to an AST, it topologically sorts them
based on declared constraints.  Then each rewriter is called with a
“context” object (where it can stash information for later passes, or
as a form of inherited or synthesized attribute (loosely as in
attribute-grammars) and the AST; it returns a (possibly) rewritten
AST.  This AST is then passed along to the next rewriter, and so on
until a final AST is produced, which is then output to the Ocaml main
compiler process.</p>
<p>Each rewriter in turn is passed an AST.  The Camlp5 ML AST has a
number of “important” types (e.g. <code class="docutils literal"><span class="pre">expr</span></code>, <code class="docutils literal"><span class="pre">patt</span></code>, <code class="docutils literal"><span class="pre">module_expr</span></code>,
<code class="docutils literal"><span class="pre">module_type</span></code>, <code class="docutils literal"><span class="pre">ctyp</span></code>, etc).  A function much like what would be
generated by <code class="docutils literal"><span class="pre">ppx_deriving.map</span></code> is called on the AST, and it
recursively walks the entire AST.  But at each of these major types,
there is an “extensible function” that gets called before calling the
(as-if-)generated “map” function, and that extensible function can
rewrite the AST (or decline and do nothing).</p>
<p>So to implement a rewriter typically means to add some code to the
extension-points that correspond to the AST types that might need to
be rewritten.  For example, in the next section we present an example
where the sole extension point would be <code class="docutils literal"><span class="pre">expr</span></code>.  In
<code class="docutils literal"><span class="pre">pa_ppx.deriving</span></code>, the types <code class="docutils literal"><span class="pre">str_item</span></code> (structure-item) and
<code class="docutils literal"><span class="pre">sig_item</span></code> (signature-item) are rewritten.  Typically, a single
rewriter only rewrites AST nodes of a few types, and then only when
they match certain criteria.  So in both extensible functions, and
normal code that does rewriting, we’ll make extensive use of
<code class="docutils literal"><span class="pre">camlp5</span></code> “quotations” (text that looks like ML surface syntax, but
is expanded by <code class="docutils literal"><span class="pre">camlp5</span></code> into ML code for patterns or expressions,
depending on context).</p>
<p>Now we can describe the steps in writing a PPX rewriter:</p>
<p>1. write some code that, for the specific AST nodes of interest,
pattern-matches and generates rewritten nodes, assuming that the nodes
are suitable.  Perhaps access lookaside information in the “context”,
or maybe stash information there for other code.</p>
<p>2. Extend the specific extensible-functions for the AST node types we
need to rewrite, using pattern-matching to select suitable nodes and
then calling our rewrite functions from step 1.</p>
<p>3. Then install these extensible functions into <code class="docutils literal"><span class="pre">Pa_ppx_base</span></code> with
indications of when they should be run (before/after which other PPX
rewriters).</p>
</div>
<div class="section" id="an-example-ppx-rewriter-based-on-pa-ppx">
<h2>An Example PPX Rewriter based on Pa_ppx<a class="headerlink" href="#an-example-ppx-rewriter-based-on-pa-ppx" title="Permalink to this headline">¶</a></h2>
<p>NOTE WELL: This code is taken from <code class="docutils literal"><span class="pre">pa_ppx/pa_here_original</span></code>, an
“original syntax” version of <code class="docutils literal"><span class="pre">pa_ppx/pa_here</span></code> . The function of
these two PPX rewriters is identical: <code class="docutils literal"><span class="pre">pa_here_original</span></code> is written
in original syntax to show that it’s straightforward to do so (no
revised syntax required (except in quotations)).</p>
<p>In this section, we will describe the simplest rewriter
(<code class="docutils literal"><span class="pre">pa_ppx.here_original</span></code>).  This rewriter replaces the extension point
<code class="docutils literal"><span class="pre">[%here]</span></code> with code that produces a <code class="docutils literal"><span class="pre">Lexing.position</span></code> of the
position in the file where the extension-point was found.  So a line (in a file “test_here.ml”):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">here</span> <span class="o">=</span> <span class="p">[</span><span class="o">%</span><span class="n">here</span><span class="p">]</span>
</pre></div>
</div>
<p>is rewritten to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">here</span> <span class="o">=</span>
  <span class="n">let</span> <span class="nb">open</span> <span class="n">Lexing</span> <span class="ow">in</span>
  <span class="p">{</span><span class="n">pos_fname</span> <span class="o">=</span> <span class="s2">&quot;test_here.ml&quot;</span><span class="p">;</span> <span class="n">pos_lnum</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">pos_bol</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
   <span class="n">pos_cnum</span> <span class="o">=</span> <span class="mi">43</span><span class="p">}</span>
</pre></div>
</div>
<p>We won’t go into excruciating detail, because this depends on a number
of <code class="docutils literal"><span class="pre">camlp5</span></code> and <code class="docutils literal"><span class="pre">pa_ppx</span></code> facilities that are described in more
detail either in the <code class="docutils literal"><span class="pre">camlp5</span></code> documentation, or elsewhere in this
documentation.</p>
<p>1. Open necessary libraries (<code class="docutils literal"><span class="pre">Pa_ppx_base</span></code> contains support
infrastructure for all PPX rewriters):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">open</span> <span class="n">Pa_ppx_base</span>
<span class="nb">open</span> <span class="n">Pa_passthru</span>
<span class="nb">open</span> <span class="n">Ppxutil</span>
</pre></div>
</div>
<p>2. Implement a function that rewrites the simple extension-point,
using <code class="docutils literal"><span class="pre">camlp5</span></code> “quotations”.  The function <code class="docutils literal"><span class="pre">quote_position</span></code> uses
quotations for expressions that themselves have anti-quotations (“holes”) for
expressions we want to fill with bits from the <code class="docutils literal"><span class="pre">Lexing.position</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>let quote_position loc p =
  let open Lexing in
  &lt;:expr&lt; let open Lexing in {
  pos_fname = $str:p.pos_fname$ ;
  pos_lnum = $int:string_of_int p.pos_lnum$ ;
  pos_bol = $int:string_of_int p.pos_bol$ ;
  pos_cnum = $int:string_of_int p.pos_cnum$ } &gt;&gt;
</pre></div>
</div>
<p>Next we write a function that pattern-matches on an expression
(expected to be <code class="docutils literal"><span class="pre">[%here]</span></code>) and rewrites it using <code class="docutils literal"><span class="pre">quote_position</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">rewrite_expr</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">function</span>
  <span class="o">&lt;</span><span class="p">:</span><span class="n">expr</span><span class="p">:</span><span class="o">&lt;</span> <span class="p">[</span><span class="o">%</span><span class="n">here</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="o">-&gt;</span>
    <span class="n">let</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">start_position_of_loc</span> <span class="n">loc</span> <span class="ow">in</span>
    <span class="n">quote_position</span> <span class="n">loc</span> <span class="n">pos</span>
<span class="o">|</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="k">assert</span> <span class="n">false</span>
</pre></div>
</div>
<p>And finally, we add this function to the “extensible function” for
expressions.  Notice the <code class="docutils literal"><span class="pre">fallback</span></code> argument below: if rewriting of
subtrees of this AST node were needed after this <code class="docutils literal"><span class="pre">pa_here_original</span></code>
rewrite, we could call that to make it happen.  The type <code class="docutils literal"><span class="pre">EF.t</span></code> is a
dispatch table of “extension points”, one for each important type in
the Camlp5 ML AST.  All these extension-points start off empty, and we
want to add our function to the extension-point for expressions
(notice the keyword “extfun”).  Then we “install” this table in the
<code class="docutils literal"><span class="pre">Pa_passthru</span></code> module, giving it a name.  We can specify that it
comes before or after other rewriters, or specify a pass number
(0..99), though this is almost never used.  Instead, by specifying
which rewriters to run before or after, we give <code class="docutils literal"><span class="pre">Pa_passthru</span></code> the
information to topologically sort all loaded rewriters before running
them:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">install</span> <span class="p">()</span> <span class="o">=</span>
<span class="n">let</span> <span class="n">ef</span> <span class="o">=</span> <span class="n">EF</span><span class="o">.</span><span class="n">mk</span> <span class="p">()</span> <span class="ow">in</span>
<span class="n">let</span> <span class="n">ef</span> <span class="o">=</span> <span class="n">EF</span><span class="o">.</span><span class="p">{</span> <span class="p">(</span><span class="n">ef</span><span class="p">)</span> <span class="k">with</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">extfun</span> <span class="n">ef</span><span class="o">.</span><span class="n">expr</span> <span class="k">with</span> <span class="p">[</span>
    <span class="o">&lt;</span><span class="p">:</span><span class="n">expr</span><span class="p">:</span><span class="o">&lt;</span> <span class="p">[</span><span class="o">%</span><span class="n">here</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="k">as</span> <span class="n">z</span> <span class="o">-&gt;</span>
    <span class="n">fun</span> <span class="n">arg</span> <span class="n">fallback</span> <span class="o">-&gt;</span>
      <span class="n">Some</span> <span class="p">(</span><span class="n">rewrite_expr</span> <span class="n">arg</span> <span class="n">z</span><span class="p">)</span>
  <span class="p">]</span> <span class="p">}</span> <span class="ow">in</span>
  <span class="n">Pa_passthru</span><span class="o">.</span><span class="p">(</span><span class="n">install</span> <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;pa_here&quot;</span><span class="p">;</span> <span class="n">ef</span> <span class="o">=</span>  <span class="n">ef</span> <span class="p">;</span> <span class="k">pass</span> <span class="o">=</span> <span class="kc">None</span> <span class="p">;</span> <span class="n">before</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">;</span> <span class="n">after</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">})</span>
<span class="p">;;</span>

<span class="n">install</span><span class="p">();;</span>
</pre></div>
</div>
<p>An example of a rewriter that specifies a “before” constraint would be
<code class="docutils literal"><span class="pre">pa_ppx.import</span></code>, which should be run before <code class="docutils literal"><span class="pre">pa_ppx.deriving</span></code>, so
that a type can be imported, and then have type-based code derived
from that imported type.</p>
</div>
<div class="section" id="troubleshooting-ppx-rewriter-invocations">
<h2>Troubleshooting PPX Rewriter Invocations<a class="headerlink" href="#troubleshooting-ppx-rewriter-invocations" title="Permalink to this headline">¶</a></h2>
<p>Everybody eventually uses a PPX rewriter that doesn’t produce the
results they desire.  There are two ways of debugging that issue:</p>
<ol class="arabic simple">
<li>using <code class="docutils literal"><span class="pre">not-ocamlfind</span> <span class="pre">preprocess</span></code></li>
<li>using the toplevel</li>
</ol>
<div class="section" id="debugging-using-not-ocamlfind-preprocess">
<h3>Debugging using <code class="docutils literal"><span class="pre">not-ocamlfind</span> <span class="pre">preprocess</span></code><a class="headerlink" href="#debugging-using-not-ocamlfind-preprocess" title="Permalink to this headline">¶</a></h3>
<p>Suppose that the <code class="docutils literal"><span class="pre">ocamlfind</span> <span class="pre">ocamlc</span></code> invocation above didn’t produce
the results we desired.  For instance, suppose that we forgot the
<code class="docutils literal"><span class="pre">-syntax</span> <span class="pre">camlp5o</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ocamlfind</span> <span class="n">ocamlc</span> <span class="o">-</span><span class="n">package</span> <span class="n">pa_ppx</span><span class="o">.</span><span class="n">deriving_plugins</span><span class="o">.</span><span class="n">show</span> <span class="o">-</span><span class="n">c</span> <span class="n">simple_show</span><span class="o">.</span><span class="n">ml</span>
<span class="n">File</span> <span class="s2">&quot;simple_show.ml&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">5</span><span class="p">,</span> <span class="n">characters</span> <span class="mi">18</span><span class="o">-</span><span class="mi">22</span><span class="p">:</span>
<span class="mi">5</span> <span class="o">|</span>   <span class="n">print_string</span> <span class="p">([</span><span class="o">%</span><span class="n">show</span><span class="p">:</span> <span class="n">a1</span><span class="p">]</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
                    <span class="o">^^^^</span>
<span class="n">Error</span><span class="p">:</span> <span class="n">Uninterpreted</span> <span class="n">extension</span> <span class="s1">&#39;show&#39;</span><span class="o">.</span>
</pre></div>
</div>
<p>We could start to debug the preprocessing process by using <code class="docutils literal"><span class="pre">not-ocamlfind</span> <span class="pre">preprocess</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="ow">not</span><span class="o">-</span><span class="n">ocamlfind</span> <span class="n">preprocess</span> <span class="o">-</span><span class="n">package</span> <span class="n">pa_ppx</span><span class="o">.</span><span class="n">deriving_plugins</span><span class="o">.</span><span class="n">show</span> <span class="n">simple_show</span><span class="o">.</span><span class="n">ml</span>
<span class="n">ppx_execute</span><span class="p">:</span> <span class="n">ocamlfind</span> <span class="ow">not</span><span class="o">-</span><span class="n">ocamlfind</span><span class="o">/</span><span class="n">papr_official</span><span class="o">.</span><span class="n">exe</span> <span class="o">-</span><span class="n">binary</span><span class="o">-</span><span class="n">output</span> <span class="o">-</span><span class="n">impl</span> <span class="n">simple_show</span><span class="o">.</span><span class="n">ml</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">simple_show4d8e59</span>
<span class="nb">format</span> <span class="n">output</span> <span class="n">file</span><span class="p">:</span> <span class="n">ocamlfind</span> <span class="ow">not</span><span class="o">-</span><span class="n">ocamlfind</span><span class="o">/</span><span class="n">papr_official</span><span class="o">.</span><span class="n">exe</span> <span class="o">-</span><span class="n">binary</span><span class="o">-</span><span class="nb">input</span> <span class="o">-</span><span class="n">impl</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">simple_show4d8e59</span>
<span class="nb">type</span> <span class="n">a1</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span> <span class="o">*</span> <span class="nb">int</span><span class="p">)[</span><span class="o">@</span><span class="nd">@deriving</span> <span class="n">show</span><span class="p">]</span>
<span class="n">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">print_string</span> <span class="p">(([</span><span class="o">%</span><span class="n">show</span> <span class="p">:</span><span class="n">a1</span><span class="p">])</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
</pre></div>
</div>
<p>This tells us we didn’t actually invoke camlp5 (or any PPX rewriters).
Instead, we use “papr_official.exe” to convert text to binary AST, and
then back to text.  A different kind of information is given by adding
<code class="docutils literal"><span class="pre">-verbose</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ocamlfind</span> <span class="n">ocamlc</span> <span class="o">-</span><span class="n">verbose</span> <span class="o">-</span><span class="n">package</span> <span class="n">pa_ppx</span><span class="o">.</span><span class="n">deriving_plugins</span><span class="o">.</span><span class="n">show</span> <span class="o">-</span><span class="n">c</span> <span class="n">simple_show</span><span class="o">.</span><span class="n">ml</span>
<span class="n">Effective</span> <span class="nb">set</span> <span class="n">of</span> <span class="n">compiler</span> <span class="n">predicates</span><span class="p">:</span> <span class="n">pkg_result</span><span class="p">,</span><span class="n">pkg_rresult</span><span class="p">,</span><span class="n">pkg_seq</span><span class="p">,</span><span class="n">pkg_stdlib</span><span class="o">-</span><span class="n">shims</span><span class="p">,</span><span class="n">pkg_fmt</span><span class="p">,</span><span class="n">pkg_sexplib0</span><span class="p">,</span><span class="n">pkg_pa_ppx</span><span class="o">.</span><span class="n">runtime</span><span class="p">,</span><span class="n">pkg_pa_ppx</span><span class="o">.</span><span class="n">deriving_plugins</span><span class="o">.</span><span class="n">show</span><span class="p">,</span><span class="n">autolink</span><span class="p">,</span><span class="n">byte</span>
</pre></div>
</div>
<p>This also tells us that camlp5 isn’t being invoked (no mention of
“preprocessor predicates”), and this would tell us that we needed to
add <code class="docutils literal"><span class="pre">-syntax</span> <span class="pre">camlp5o</span></code> (and maybe the <code class="docutils literal"><span class="pre">camlp5</span></code> package):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="ow">not</span><span class="o">-</span><span class="n">ocamlfind</span> <span class="n">preprocess</span> <span class="o">-</span><span class="n">package</span> <span class="n">pa_ppx</span><span class="o">.</span><span class="n">deriving_plugins</span><span class="o">.</span><span class="n">show</span> <span class="o">-</span><span class="n">syntax</span> <span class="n">camlp5o</span> <span class="n">simple_show</span><span class="o">.</span><span class="n">ml</span>
</pre></div>
</div>
<p>will produce binary output, because we didn’t specify what syntax we
wanted to print (official or revised); adding <code class="docutils literal"><span class="pre">camlp5.pr_o</span></code> will fix that:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="ow">not</span><span class="o">-</span><span class="n">ocamlfind</span> <span class="n">preprocess</span> <span class="o">-</span><span class="n">package</span> <span class="n">pa_ppx</span><span class="o">.</span><span class="n">deriving_plugins</span><span class="o">.</span><span class="n">show</span><span class="p">,</span><span class="n">camlp5</span><span class="o">.</span><span class="n">pr_o</span> <span class="o">-</span><span class="n">syntax</span> <span class="n">camlp5o</span> <span class="n">simple_show</span><span class="o">.</span><span class="n">ml</span>
</pre></div>
</div>
<p>Basically, any <code class="docutils literal"><span class="pre">ocamlfind</span> <span class="pre">ocamlc</span></code> command can be converted to
<code class="docutils literal"><span class="pre">not-ocamlfind</span> <span class="pre">preprocess</span></code> by removing any flags/arguments that are
meant only for ocamlc (so: linking, warnings, <code class="docutils literal"><span class="pre">-c</span></code>, etc) and adding
a camlp5 printing package (so: <code class="docutils literal"><span class="pre">camlp5.pr_o</span></code> or <code class="docutils literal"><span class="pre">camlp5.pr_r</span></code>).</p>
</div>
<div class="section" id="debugging-using-the-ocaml-toplevel">
<h3>Debugging using the ocaml toplevel<a class="headerlink" href="#debugging-using-the-ocaml-toplevel" title="Permalink to this headline">¶</a></h3>
<p>The other way to debug a <code class="docutils literal"><span class="pre">Pa_ppx</span></code> rewriter is via the Ocaml
toplevel.  Camlp5 and <code class="docutils literal"><span class="pre">pa_ppx</span></code> packages can be loaded into the
toplevel in the usual way.</p>
<ol class="arabic">
<li><p class="first">Load supporting modules:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#use &quot;topfind.camlp5&quot;;;</span>
<span class="c1">#require &quot;camlp5.pa_o&quot;;;</span>
<span class="c1">#require &quot;camlp5.pr_o&quot;;;</span>
<span class="c1">#directory &quot;../tests-ounit2&quot;;;</span>

<span class="p">(</span><span class="o">*</span> <span class="n">these</span> <span class="n">are</span> <span class="n">needed</span> <span class="n">by</span> <span class="n">this</span> <span class="n">example</span><span class="p">,</span> <span class="ow">not</span> <span class="n">by</span> <span class="n">pa_ppx</span> <span class="o">*</span><span class="p">)</span>
<span class="c1">#require &quot;compiler-libs.common&quot; ;;</span>
<span class="c1">#require &quot;bos&quot;;;</span>

<span class="c1">#load &quot;../tests-ounit2/papr_util.cmo&quot;;;</span>
<span class="nb">open</span> <span class="n">Papr_util</span> <span class="p">;;</span>
</pre></div>
</div>
</li>
<li><p class="first">Load the PPX rewriter:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#require &quot;pa_ppx.deriving_plugins.show&quot;;;</span>
</pre></div>
</div>
</li>
<li><p class="first">And run it on a file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="s2">&quot;simple_show.ml&quot;</span> <span class="o">|&gt;</span> <span class="n">Fpath</span><span class="o">.</span><span class="n">v</span> <span class="o">|&gt;</span> <span class="n">Bos</span><span class="o">.</span><span class="n">OS</span><span class="o">.</span><span class="n">File</span><span class="o">.</span><span class="n">read</span>
<span class="o">|&gt;</span> <span class="n">Rresult</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">get_ok</span> <span class="o">|&gt;</span> <span class="n">PAPR</span><span class="o">.</span><span class="n">Implem</span><span class="o">.</span><span class="n">pa1</span>
<span class="o">|&gt;</span> <span class="n">PAPR</span><span class="o">.</span><span class="n">Implem</span><span class="o">.</span><span class="n">pr</span> <span class="o">|&gt;</span> <span class="n">print_string</span> <span class="p">;;</span>
<span class="nb">type</span> <span class="n">a1</span> <span class="o">=</span> <span class="nb">int</span> <span class="o">*</span> <span class="nb">int</span><span class="p">[</span><span class="o">@</span><span class="nd">@deriving_inline</span> <span class="n">show</span><span class="p">]</span><span class="n">let</span> <span class="n">rec</span> <span class="p">(</span><span class="n">pp_a1</span> <span class="p">:</span> <span class="n">a1</span> <span class="n">Fmt</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">fun</span> <span class="p">(</span><span class="n">ofmt</span> <span class="p">:</span> <span class="n">Format</span><span class="o">.</span><span class="n">formatter</span><span class="p">)</span> <span class="n">arg</span> <span class="o">-&gt;</span>
    <span class="p">(</span><span class="n">fun</span> <span class="p">(</span><span class="n">ofmt</span> <span class="p">:</span> <span class="n">Format</span><span class="o">.</span><span class="n">formatter</span><span class="p">)</span> <span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="n">let</span> <span class="nb">open</span> <span class="n">Pa_ppx_runtime</span><span class="o">.</span><span class="n">Runtime</span><span class="o">.</span><span class="n">Fmt</span> <span class="ow">in</span>
       <span class="n">pf</span> <span class="n">ofmt</span> <span class="s2">&quot;(@[</span><span class="si">%a</span><span class="s2">,@ </span><span class="si">%a</span><span class="s2">@])&quot;</span>
         <span class="p">(</span><span class="n">fun</span> <span class="n">ofmt</span> <span class="n">arg</span> <span class="o">-&gt;</span>
            <span class="n">let</span> <span class="nb">open</span> <span class="n">Pa_ppx_runtime</span><span class="o">.</span><span class="n">Runtime</span><span class="o">.</span><span class="n">Fmt</span> <span class="ow">in</span> <span class="n">pf</span> <span class="n">ofmt</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="n">arg</span><span class="p">)</span>
         <span class="n">v0</span>
         <span class="p">(</span><span class="n">fun</span> <span class="n">ofmt</span> <span class="n">arg</span> <span class="o">-&gt;</span>
            <span class="n">let</span> <span class="nb">open</span> <span class="n">Pa_ppx_runtime</span><span class="o">.</span><span class="n">Runtime</span><span class="o">.</span><span class="n">Fmt</span> <span class="ow">in</span> <span class="n">pf</span> <span class="n">ofmt</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="n">arg</span><span class="p">)</span>
         <span class="n">v1</span><span class="p">)</span>
      <span class="n">ofmt</span> <span class="n">arg</span><span class="p">[</span><span class="o">@</span><span class="nd">@ocaml</span><span class="o">.</span><span class="n">warning</span> <span class="s2">&quot;-39&quot;</span><span class="p">]</span> <span class="p">[</span><span class="o">@</span><span class="nd">@ocaml</span><span class="o">.</span><span class="n">warning</span> <span class="s2">&quot;-33&quot;</span><span class="p">]</span>
<span class="ow">and</span> <span class="p">(</span><span class="n">show_a1</span> <span class="p">:</span> <span class="n">a1</span> <span class="o">-&gt;</span> <span class="n">Stdlib</span><span class="o">.</span><span class="n">String</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span>
  <span class="n">fun</span> <span class="n">arg</span> <span class="o">-&gt;</span> <span class="n">Format</span><span class="o">.</span><span class="n">asprintf</span> <span class="s2">&quot;</span><span class="si">%a</span><span class="s2">&quot;</span> <span class="n">pp_a1</span> <span class="n">arg</span><span class="p">[</span><span class="o">@</span><span class="nd">@ocaml</span><span class="o">.</span><span class="n">warning</span> <span class="s2">&quot;-39&quot;</span><span class="p">]</span> <span class="p">[</span><span class="o">@</span><span class="nd">@ocaml</span><span class="o">.</span><span class="n">warning</span> <span class="s2">&quot;-33&quot;</span><span class="p">][</span><span class="o">@@</span><span class="nd">@end</span><span class="p">]</span><span class="n">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">print_string</span> <span class="p">((</span><span class="n">fun</span> <span class="n">arg</span> <span class="o">-&gt;</span> <span class="n">Format</span><span class="o">.</span><span class="n">asprintf</span> <span class="s2">&quot;</span><span class="si">%a</span><span class="s2">&quot;</span> <span class="n">pp_a1</span> <span class="n">arg</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span><span class="o">-</span> <span class="p">:</span> <span class="n">unit</span> <span class="o">=</span> <span class="p">()</span>
<span class="c1">#</span>
</pre></div>
</div>
</li>
</ol>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="builtins.html" class="btn btn-neutral float-right" title="Built-in PPX Rewriters" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="installation.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Chet Murthy. All rights reserved.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>